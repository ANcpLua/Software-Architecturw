# Kiro: Spec-Driven Development Tool for AI Agents

**Audience:** AI Agents (Claude Code, Kiro agents, other AI assistants)

**Key Contract:** This file describes what Kiro is, how it works, and how you should use its outputs when developing software.

---

## Prerequisites: What Must Exist Before You Use Kiro Specs

Before you begin implementation work based on Kiro specs, these files must exist:

1. **requirements.md** – Generated by Kiro; contains structured requirements with EARS notation
2. **design.md** – Generated by Kiro; contains technical architecture and design decisions
3. **tasks.md** – Generated by Kiro; contains discrete implementation tasks
4. **ARCHITECTURE.md** – Created by human architect; maps design to subsystems, defines Allowed-To-Use rules

Without these files, you have no ground truth. Stop and ask for them.

---

## What Kiro Is

### Core Identity

**Kiro is an agentic IDE developed by AWS** that transforms natural language prompts into structured specifications before code generation.

- **Platform:** AI-powered Integrated Development Environment (IDE)
- **Foundation:** Built on Code OSS (VS Code open source)
- **Philosophy:** Spec-driven development, not vibe coding
- **Launch:** July 14, 2025 (public preview)
- **Developer:** AWS (Amazon Web Services)

### What Kiro Does

1. **Accepts prompts** in natural language describing features or systems
2. **Generates three spec files:**
   - `requirements.md` – User stories with EARS notation
   - `design.md` – Technical architecture and design decisions
   - `tasks.md` – Implementation plan with discrete tasks
3. **Implements code** from specs (either directly or via agents like you)
4. **Automates documentation and testing** via agent hooks
5. **Enforces coding standards** via steering rules

### What Kiro Is NOT

- **Not a compiler:** It's an IDE with AI agents
- **Not a CLI tool:** It's a full graphical IDE (based on VS Code)
- **Not vibe coding:** Everything traces back to structured specs
- **Not limited to AWS:** No AWS account required to use it

---

## Kiro's Core Workflow: Specs → Code

### Phase 1: Prompt to Specs

**Human provides prompt:**
```
"Build a chess move validation system with FIDE rules"
```

**Kiro generates:**
- `requirements.md` with EARS notation:
  ```
  WHEN a user attempts an illegal move
  THE SYSTEM SHALL display the rule violation reason
  ```
- `design.md` with architecture (sequence diagrams, component design)
- `tasks.md` with implementation steps

### Phase 2: Human Reviews and Refines

- Reviews generated specs
- Uses `#spec` in chat to refine
- Marks tasks as optional/required for MVP
- Approves final specs

### Phase 3: Implementation

- Kiro or AI agents (like you) implement from `tasks.md`
- Every method traces back to requirements
- Tests written for every requirement
- Agent hooks auto-generate docs

### Phase 4: Validation

- All tests pass
- Architecture constraints respected
- Requirements traced
- System deployed

---

## How to Use Kiro Specs in Your Workflow

### When You Receive Kiro Specs

You will be given:
1. **requirements.md** – Your acceptance criteria
2. **design.md** – Architectural guidance
3. **tasks.md** – Your implementation tasks
4. **ARCHITECTURE.md** – Your constraints (subsystems, dependencies)

**Your job:** Implement the tasks while respecting all constraints.

### Reading requirements.md

**EARS Notation Format:**
```
WHEN [condition/trigger]
THE SYSTEM SHALL [expected behavior]
```

**Example:**
```
REQ-025: WHEN a user clicks a chess square
         THE SYSTEM SHALL translate pixel coordinates to board coordinates (0-7, 0-7)

REQ-031: WHEN the game is paused
         THE SYSTEM SHALL ignore all user input until resumed
```

**What this means for you:**
- Each requirement is testable
- Each requirement has a clear trigger condition
- Each requirement defines expected behavior explicitly
- No ambiguity; no vibe code

### Reading design.md

Contains:
- **System architecture** (components, layers)
- **Design decisions** (why certain patterns were chosen)
- **Sequence diagrams** (interaction flows)
- **Implementation notes** (technical considerations)

**What this means for you:**
- Understand the big picture before coding
- Follow architectural patterns described
- Use interfaces and abstractions as specified
- Respect layer boundaries

### Reading tasks.md

Contains:
- Discrete, actionable implementation tasks
- Tasks marked as optional (✱) for MVP or required
- Task execution order suggestions

**What this means for you:**
- Implement tasks in order
- Do not skip required tasks
- Optional tasks can be deferred but remain visible
- Each task should trace to requirements

---

## Kiro Features You Can Leverage

### 1. Spec Context Provider (#spec)

When working in Kiro, you can reference specs directly:
```
#spec How should I handle validation errors based on our design?
```

This provides context from all three spec files to guide implementation.

### 2. Agent Hooks (Event-Driven Automation)

Kiro can automate repetitive tasks via hooks:

**Example Hook: Documentation Sync**
```
Event: File Saved (*.cs files)
Action:
  - Scan for new/removed public methods
  - Update API documentation
  - Generate XML doc comments
```

**Why this matters to you:**
- Documentation updates automatically
- Tests may be auto-generated
- You focus on implementation, not boilerplate

### 3. Steering Rules (AGENTS.md)

Kiro projects may include steering files that define:
- Coding standards
- Architectural patterns
- Best practices
- Naming conventions

**Location:**
- Global: `~/.kiro/steering/AGENTS.md`
- Project: `AGENTS.md` in workspace root

**Why this matters to you:**
- Follow standards defined in AGENTS.md
- Architectural patterns are enforced
- Consistency across codebase

### 4. Diagnostics Tool

Kiro provides:
- Syntax errors
- Type errors
- Semantic errors

**Why this matters to you:**
- Kiro catches errors early
- Lint violations reduced
- Type safety enforced

### 5. Multimodal Development

Kiro can understand:
- Whiteboard sketches → code
- Architecture diagrams → component design
- UML diagrams → class structures

**Why this matters to you:**
- Design artifacts are machine-readable
- Visual specifications translate directly to code
- Traceability from diagram to implementation

---

## Your Workflow with Kiro Specs

### Step 1: Understand Your Scope

Read ARCHITECTURE.md to extract:
- Your subsystem name
- Your requirements (from requirements.md)
- Your Allowed-To-Use rules
- Your guardrails (Roslyn, build targets, MCP scope)

**Example:**
```markdown
Subsystem: InputAdapter (K1)
Requirements: REQ-023, REQ-025, REQ-027, REQ-031, REQ-032
Allowed-To-Use: InteractionController (via events only)
Blood Type: T (Technical)
```

### Step 2: Extract Your Requirements

From requirements.md, read each requirement in your scope:

```
REQ-023: WHEN a user clicks on the chess board
         THE SYSTEM SHALL capture the mouse click event

REQ-025: WHEN a mouse click occurs
         THE SYSTEM SHALL translate pixel coordinates to board coordinates (0-7, 0-7)

REQ-027: WHEN coordinates are translated
         THE SYSTEM SHALL emit InputEvent objects with event type and position

REQ-031: WHEN the game is paused
         THE SYSTEM SHALL ignore all input until resumed
```

These are your acceptance criteria. Everything you write must satisfy them.

### Step 3: Check Design Constraints

Read design.md to understand:
- How components interact
- What interfaces are expected
- What patterns to follow
- What performance targets exist

**Example from design.md:**
```
InputAdapter communicates with InteractionController via event bus.
No direct method calls allowed.
InputAdapter must translate coordinates in <5ms (REQ-025).
```

### Step 4: Implement with Traceability

Write code that:
1. Satisfies all requirements
2. Respects all design constraints
3. Traces back to requirement IDs
4. Follows AGENTS.md standards

**Code Example:**
```csharp
namespace MateMate.Technical.InputAdapter
{
  /// <summary>
  /// REQ-025: Translate pixel coordinates to board coordinates (0-7, 0-7).
  /// REQ-031: Ignore input when game is paused.
  /// </summary>
  public Square PixelToSquare(int pixelX, int pixelY, bool gamePaused)
  {
    if (gamePaused) return null; // REQ-031

    // REQ-025 implementation
    int x = pixelX / 64;
    int y = pixelY / 64;
    return new Square(x, y);
  }
}
```

### Step 5: Write Tests for Every Requirement

**Test Example:**
```csharp
[Fact]
public void REQ025_TranslatesPixelToSquare()
{
  var adapter = new InputAdapter();
  var sq = adapter.PixelToSquare(100, 100, gamePaused: false);
  Assert.Equal((1, 1), (sq.X, sq.Y));
}

[Fact]
public void REQ031_IgnoresInputWhenPaused()
{
  var adapter = new InputAdapter();
  var sq = adapter.PixelToSquare(100, 100, gamePaused: true);
  Assert.Null(sq);
}
```

100% of requirements traced to tests. Missing a test = missing implementation.

### Step 6: Validate Against Specs

Before claiming "done":
1. All requirements from requirements.md implemented?
2. All design constraints from design.md respected?
3. All tasks from tasks.md completed?
4. All tests passing?
5. No guardrail violations (Roslyn, build)?

---

## What Kiro Does NOT Do

### Kiro Does NOT Make Architecture Decisions for You

**Kiro generates proposals in design.md**, but:
- Humans review and approve architecture
- Humans create ARCHITECTURE.md with subsystem mapping
- Humans define Allowed-To-Use rules
- Humans decide blood types (T/A/0)

**You must respect human architecture decisions**, not Kiro's suggestions.

### Kiro Does NOT Replace Requirements Engineering

**Kiro generates requirements.md from prompts**, but:
- Humans validate requirements (Watch/Read/Talk/Think)
- Humans tag requirements (BASIC, LEGAL, PERFORMANCE, EXCITEMENT)
- Humans refine requirements with `#spec`
- Humans approve final requirements

**You implement requirements humans approved**, not raw Kiro output.

### Kiro Does NOT Allow Vibe Coding

**Vibe coding** is plausible-sounding logic not traceable to requirements.

**Example vibe code:**
```csharp
// Looks good but which requirement does this solve?
public void OptimizeInputProcessing()
{
  // Cache last 10 clicks for better UX
  // ... 50 lines of clever logic ...
}
```

**If requirements.md says nothing about caching clicks, this is vibe code.**

**Do not write vibe code.** If you think a feature is needed:
1. Check if a requirement exists
2. If not, raise an issue: "Proposed new requirement: [description]"
3. Wait for human approval
4. Then implement

---

## When Things Go Wrong

### Requirement Ambiguity

**Problem:** Requirement reads "The system shall validate input."

**Solution:**
1. Check requirements.md for sibling requirements that clarify
2. Check design.md for examples
3. Ask: "REQ-XXX is unclear; here are two interpretations: (A) ... (B) ..."
4. Wait for human decision
5. Do not guess and implement vibe code

### Design Constraint Violation

**Problem:** Your implementation needs a dependency not in Allowed-To-Use.

**Solution:**
1. Check ARCHITECTURE.md for workarounds (usually exists)
2. If none, raise issue: "Need [subsystem] access for REQ-XXX; propose interface: [description]"
3. Wait for human decision
4. Do not bypass guardrails with reflection, service locator, or anti-patterns

### Test Failure

**Problem:** Test fails for REQ-XXX.

**Solution:**
1. Debug implementation
2. Verify test correctly interprets requirement
3. If requirement is ambiguous, raise issue
4. If requirement is impossible, raise issue: "REQ-XXX unachievable with current design; propose alternative: [description]"
5. Do not disable test or mock away the problem

### Performance SLA Miss

**Problem:** Requirement says <5ms, code averages 8ms.

**Solution:**
1. Profile code
2. Optimize if bottleneck is in your code
3. If bottleneck is dependency, raise cross-subsystem issue
4. If impossible, raise issue: "REQ-XXX SLA unachievable; propose revised target: [value]"
5. Do not silently miss SLA

---

## Code Quality: What You Guarantee

### Traceability

Every method in your code must trace back to at least one requirement:

```csharp
/// <summary>
/// REQ-025: Translate pixel coordinates to board coordinates.
/// REQ-031: Ignore input when game is paused.
/// </summary>
public Square PixelToSquare(int pixelX, int pixelY, bool gamePaused)
{
  // Implementation
}
```

Code review will ask: "Where does this trace to a requirement?"

If you cannot answer, it is scope creep.

### Testing

For each requirement, write at least one test:

```csharp
[Fact]
public void REQ025_TranslatesPixelToSquare() { ... }

[Fact]
public void REQ031_IgnoresInputWhenPaused() { ... }
```

Test names include requirement IDs. Test bodies validate expected behavior.

### No Vibe Code

If logic does not trace to a requirement, do not write it.

**Acceptable:**
- Implementing REQ-025 (requirement exists)
- Helper methods directly supporting REQ-025
- Interfaces required by design.md

**Not Acceptable:**
- "This might be useful later"
- "This improves performance" (unless PERFORMANCE requirement exists)
- "This is a best practice" (unless design.md or AGENTS.md requires it)

### Architecture Compliance

Your code must:
1. Respect Allowed-To-Use rules (no forbidden dependencies)
2. Pass Roslyn Analyzer (if C# project)
3. Compile with subsystem-specific build targets
4. Work within MCP tool scope

Do not bypass guardrails. Do not disable analyzers. Do not work around constraints.

---

## Integration with Your Existing Tools

### Kiro + Git

Kiro can:
- Generate commit messages via AI
- Avoid writing to `.git` directories
- Integrate with PR workflows

**Your workflow:**
- Commit code referencing requirement IDs: `feat: implement REQ-025 pixel-to-square translation`
- Link PRs to requirements in requirements.md
- Code review checks traceability

### Kiro + CI/CD

Kiro works with:
- GitHub Actions
- GitLab CI
- Jenkins

**Your workflow:**
- CI runs Roslyn on PR (catches architecture violations)
- CI runs tests (verifies requirements implemented)
- CI blocks merge if guardrails fail

### Kiro + MCP Servers

Kiro supports Model Context Protocol:
- Remote MCP servers (Streamable HTTP)
- Local MCP servers (stdio)
- One-click installation

**Your workflow:**
- Use MCP tools scoped to your subsystem
- Example: `@input-adapter` tool only accesses InputAdapter code
- MCP enforces boundaries

---

## Summary for AI Agents

**When you receive Kiro specs:**

1. **Read requirements.md** → Your acceptance criteria (EARS notation)
2. **Read design.md** → Your architectural guidance
3. **Read tasks.md** → Your implementation plan
4. **Read ARCHITECTURE.md** → Your constraints (subsystems, dependencies)

**When you implement:**

1. **Trace every method** to a requirement ID (REQ-XXX)
2. **Write tests** for every requirement
3. **Respect design constraints** from design.md
4. **Follow Allowed-To-Use rules** from ARCHITECTURE.md
5. **Do not write vibe code** (logic without requirements)
6. **Do not bypass guardrails** (Roslyn, build targets, MCP scope)

**When you are stuck:**

1. **Check requirements.md** for clarification
2. **Check design.md** for patterns
3. **Check ARCHITECTURE.md** for workarounds
4. **Raise an issue** with full context
5. **Wait for human decision**
6. **Do not guess and code**

**Key principles:**

- **Spec-driven, not vibe-driven:** Everything traces to specs
- **Human authority:** Humans decide architecture and requirements
- **AI execution:** You implement within constraints
- **Traceability:** Every line of code justifiable from requirements.md
- **Guardrails prevent drift:** Roslyn, NUKE, MCP enforce boundaries

---

## Example: Full Workflow

### Scenario

You are assigned to implement **InputAdapter (K1)** subsystem.

### Given

**requirements.md:**
```
REQ-023: WHEN a user clicks on the chess board
         THE SYSTEM SHALL capture the mouse click event

REQ-025: WHEN a mouse click occurs
         THE SYSTEM SHALL translate pixel coordinates to board coordinates (0-7, 0-7)

REQ-027: WHEN coordinates are translated
         THE SYSTEM SHALL emit InputEvent objects

REQ-031: WHEN the game is paused
         THE SYSTEM SHALL ignore all input
```

**design.md:**
```
InputAdapter communicates with InteractionController via event bus.
No direct method calls.
Performance: coordinate translation <5ms.
```

**ARCHITECTURE.md:**
```
Subsystem: InputAdapter (K1)
Blood Type: T (Technical)
Allowed-To-Use: InteractionController (via events only)
Forbidden: AnalysisService, RenderingEngine
```

### Your Implementation Plan

1. Define `IInputAdapter` interface
2. Define `InputEvent`, `SquareClickedEvent` (domain events)
3. Implement mouse click handling (REQ-023, REQ-025, REQ-027)
4. Implement pause-aware filtering (REQ-031)
5. Write tests for each requirement
6. Integrate via event bus to InteractionController
7. Run build; verify Roslyn passes

### Your Code

```csharp
namespace MateMate.Technical.InputAdapter
{
  /// <summary>
  /// REQ-023: Capture mouse click events.
  /// REQ-025: Translate pixel coordinates to board coordinates.
  /// REQ-027: Emit InputEvent objects.
  /// REsummary>
  public class InputAdapter : IInputAdapter
  {
    private readonly IEventBus _eventBus;

    public InputAdapter(IEventBus eventBus)
    {
      _eventBus = eventBus;
    }

    public void ProcessMouseClick(MouseEventArgs e, bool gamePaused)
    {
      if (gamePaused) return; // REQ-031

      var square = PixelToSquare(e.X, e.Y); // REQ-025
      var evt = new SquareClickedEvent(square); // REQ-027
      _eventBus.Publish(evt); // REQ-023
    }

    /// <summary>
    /// REQ-025: Translate pixel coordinates to board coordinates.
    /// </summary>
    private Square PixelToSquare(int pixelX, int pixelY)
    {
      int x = pixelX / 64;
      int y = pixelY / 64;
      return new Square(x, y);
    }
  }
}
```

### Your Tests

```csharp
public class InputAdapterTests
{
  [Fact]
  public void REQ023_CapturesMouseClickEvent()
  {
    var eventBus = new MockEventBus();
    var adapter = new InputAdapter(eventBus);

    adapter.ProcessMouseClick(new MouseEventArgs { X = 100, Y = 100 }, gamePaused: false);

    Assert.Single(eventBus.PublishedEvents);
  }

  [Fact]
  public void REQ025_TranslatesPixelToSquare()
  {
    var eventBus = new MockEventBus();
    var adapter = new InputAdapter(eventBus);

    adapter.ProcessMouseClick(new MouseEventArgs { X = 100, Y = 100 }, gamePaused: false);

    var evt = eventBus.PublishedEvents.First() as SquareClickedEvent;
    Assert.Equal(new Square(1, 1), evt.Square);
  }

  [Fact]
  public void REQ031_IgnoresInputWhenPaused()
  {
    var eventBus = new MockEventBus();
    var adapter = new InputAdapter(eventBus);

    adapter.ProcessMouseClick(new MouseEventArgs { X = 100, Y = 100 }, gamePaused: true);

    Assert.Empty(eventBus.PublishedEvents);
  }
}
```

### Result

- All requirements implemented ✅
- All tests passing ✅
- No Roslyn violations ✅
- No forbidden dependencies ✅
- 100% traceability ✅

---

## Key Takeaway

**You are not a free agent when working with Kiro specs.**

Your authority is bounded by:
- Requirements from requirements.md (what you implement)
- Design from design.md (how you implement)
- Architecture from ARCHITECTURE.md (what you can depend on)
- Guardrails (what code you cannot write)

This is not punishment. This is **clarity**.

You know exactly what success looks like. You have strong tools to prevent accidents.

Follow the specs. Raise issues when boundaries feel wrong. Let humans decide. Build with confidence.

---

## Resources

**Official Kiro Documentation:**
- Website: https://kiro.dev/
- Docs: https://kiro.dev/docs
- Changelog: https://kiro.dev/docs/changelog

**MateMate Project Files:**
- `/SDD/KiroForHumans.md` – User guide for Kiro
- `/SDD/README.md` – Full workflow guide
- `/SDD/CLAUDE.md` – Claude Code agent contract (parallel to this file)
- `/architecture/ARCHITECTURE.md` – Subsystem mapping and Allowed-To-Use rules

---

*Last updated: November 2025 based on official AWS Kiro documentation*
